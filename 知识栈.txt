Require
ToLua中会在package的searchers中又加了一个加载器 这个加载器是C层的一个方法
如何管理好每个界面的资源
用BuildAssetBundles的方式去打ab包时,每个资源都会去找相关依赖的资源是否有ab名，如果有的话会直接把依赖资源打成ab包，及时你并没有去打这个依赖资源。
如果这个依赖资源并没有相关ab信息的话就会直接把这个依赖打进目标ab包中。
特效
1.GC的触发机制
2.GC的清理机制
3.GC的一些相关配置

C# GC是基于“代”的概念，C#的GC会在代满的时候触发GC，并将最后幸存下来的对象放置到上一代，久而久之第2代（祖先）的对象会更加稳定。 
遍历所有堆栈中的局部变量，方法参数，静态变量是否引用了对象，是的话就把同步位索引设置成0
垃圾回收时会暂停所有线程 和Lua不同所有他们用了不同的GC算法  两色标记 和 三色标记

经常会把位运算中左移右移的概念搞反，原因可能是没理解高位在后，低位在前，比如 1000000 常常把这个值当成是1 其实这是一个非常大的值，应该是00000001

C# 调用 Lua 实际上是 C#调用lua的C API 去和Lua交互
Lua 调用 C# 

msg 延迟调用 缓存

protocolbuf 实现 编译器 proto 
pbc 需要准备 pb文件（由proto转换而来）首先需要把pb字节都注册到pbc中 前后端公用的协议ID 分别对应各个协议名  数据结构  四字节 数据大小  四字节 协议id  xxx字节 主要内容
客户端获取到协议ID 然后知道对应的协议再用pbc来解析数据
C#的protobuf解析分析：在将proto编译成cs文件时，编译器会直接把固定的序列化反序列硬编码到方法中，通过tag来区分不同的字段

战斗准备工作 
1.加载两边阵容的模型预制 动画 音效 特效 统一处理所有模型依赖到的资源
Hero : buff Hp animator  
BattleManager管理heros 

PlayMaker 一个状态机 继承Mono 挂载在游戏物体上， 给游戏对象赋予了状态的概念，可以对各种状态进行各种逻辑处理（Action）及在不同状态之间的逻辑转换（Event）

UIRoot:Content Width  Content Height  设备分辨率会通过这个分辨率来计算出一个基于这个分辨率的分辨率来适应UI，说白了就是让设备分辨率接近游戏设置的分辨率，让他们看起来不要差太多

批处理一般用于静态物体，只需要进行一次合并然后把数据提交给GPU就结束了，但是动态物体每帧都需要渲染，所以每帧都需要提交drawcall给GPU就导致了每帧CPU都需要大量的运算合并
一次drawcall,GPU会使用相同的渲染状态来绘制，所以批处理的物体必须是相同的渲染状态


协程同步调用 SetShaderColor 

... 只能放在参数末尾，否则是提取第一个参数

游戏中的红点系统
实现内容
1.所有红点动态生成，数据改变能改及时刷新当前显示中的红点
思路一.
通过注册所有红点事件 参数1 生成红点的父物体 参数2 是否生成红点的func  不显示时移除注册
刷新红点的方式1. 数据改变通过广播的方式来刷新 但是得处理每一条红点数据  方式2.通过update每帧刷新当前注册且显示的红点


Lua Table 简单总结一下Table的用法对应C源码中是如何实现
1. Table的查找 t[1] t[1.2] t["xx"] t[func] ..
ltable luaH_get 首先会判断key的类型，若key是整型并且在数组的范围之内会直接返回对应数组元素 key-1 就代表lua下标是从1开始
然后其余会根据类型计算hash然后找到对应Node节点，然后比较Node节点中的Key值是否与目标Key值相等，
若相等就直接返回Value，若不相等则在Node的链表上寻找若还是没有该值则返回nil

2. Table的赋值
首先会查找是否有对应的key，若有直接赋值即可，若没有则查看hash表是否有多余的空间，有就存放在hash表中，若没有则会resize数组和hash表（resize只会发生在判断hash的时候）
比如 a={} a[1] = 1   首先lua会去寻找数组中是否存在该key（判断key是否在数组范围内）是的话直接返回该值 但有可能该值为nil。这里的话因为数组大小为0，所以在hash中寻找 显然没找到这时
resize数组和hash表，遍历这两个数组筛选int类型的key，根据下述规则分配元素，先是(0.5,1] a[1] 符合区间 且利用率大于百分之五十，所以扩张数组到1再因为 int元素为1 > 1 / 2 继续循环 (1,2] 元素为0
数组大小还是为1，  1 == 2 / 2 跳出循环， 最终数组大小为1 
3. Table的resize规则: 
	array：
	table会计算array中所有元素的数量和node中number类型的元素的数量的总和
	在计算每个区间内（(2^lg-1,2^lg]）的元素数量，一般情况下 size由array的元素决定
4. ipair  --ipairs 返回了三个值给 for 循环来进行迭代: 迭代函数, 迭代对象 (函数的第一个参数), 以及迭代初始值 0。迭代函数 ipairsaux
ipair只是简单的每次增加1 然后返回相应的值 若遇到nil则停止迭代

5. pairs 会先去寻找元方法_pairs，若找到了则直接带上迭代只执行元方法，否则会先去数组中寻找迭代值是否在范围内，若是就返回并且每次
+1来迭代，若为空则调用C方法来进行迭代,与ipair相同 返回三个参数 迭代函数，迭代对象（函数的第一个参数），以及迭代值初始值为nil


透明度混合必须得关闭深度写入，并且在不透明物渲染后渲染。
如果开启深度写入，在透明物后面的物体不会被渲染，主要是因为透明物可以看到其后面物体的差别

图像渲染中 每个顶点的渲染在哪个坐标空间并不重要，重要的是其他信息（如视图方向，灯光方向）也要转换到相应的空间，每个顶点都应该接受光照的处理
每次都会把uv的概念搞混,这次好好记录一下。  模型上面的uv 其实和贴图上的uv是一一对应的，知道两个模型的uv就可以知道他们之间的所有uv坐标，从而就可以从uv对应的贴图像素填充到模型上，而模型上的uv又对应相应的顶点。
