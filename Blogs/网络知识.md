数字签名:证明自己的身份。  用自己的私钥进行签名, 别人用公钥进行解密,如果解密成功,代表消息是你发的。
数字证书:由权威机构颁发同样是代表自己的身份,它的作用是证明公钥拥有者的身份。
TLS：(Transport Layer Security) 传输层安全协议, 作用是保证数据安全传输。大致原理是 通讯双方协商加密算法和互发一些算法参数最终生成一个会话密钥
,然后服务器会发送证书给客户端,客户端确认证书是可信的之后用证书的公钥对会话密钥进行加密,用会话密钥对通讯数据进行加密传送给服务器,服务器在通过私钥进行解密
获取到会话密钥,在通过会话密钥对通讯数据进行解密


HTTP/2 前身 SPDY：
基于TSL ,一次TCP连接 多路复用  SPDY 必须使用TLS 来保证通信的可靠性和安全性。 HTTP/2 修改了压缩算法  基于哈夫曼算法 
HTTP/2新特性：
1.只使用了一次TCP连接完成所有Http请求,HTTP/1.1 每次发起请求都需要建立TCP连接,结束之后再关闭,这导致在请求频繁的场景下造成性能和资源浪费。
2.HTTP/2使用流的概念,所有数据都通过帧来发送（二进制）,在此基础上增加了多路复用,为每个帧编号将多次请求合并打乱发送,发送到之后在通过编号来复原数据
3.压缩表头，HPACK 算法等。 原理大致是实际使用场景中表头大部分内容冗余 每次只发送更改部分  
HTTP/2  向下兼容HTTP/1.1, 
HTTP/3：希望解决HTTP/2的队头阻塞问题,可能使用UDP协议


TCP三次握手:双方交互可靠连接必须的信息,如序列号seq  确认号 ack 窗口大小 选择性确认等,两次握手是可以完成信息的共享，但是在一些情况下可能会导致资源浪费，比如： 
客户端发送第一次请求(Syn)时没有及时送达,于是客户端又发了一个(syn)连接请求,等到这一次TCP连接结束时 正好第一次请求发送到了服务器,由于服务器端无法判断这是一个  
错误的请求,于是就又与客户端建立了连接,但是客户端可能已经不维护这个连接,于是服务器消耗了不必要的资源。所以再加上一次确认来保证  
“三次握手”的目的是“为了防止已失效的连接(connect)请求报文段传送到了服务端，因而产生错误”  
TCP四次挥手:比如我想断开连接 我向服务端发送Fin请求,服务器返回Ack, 表明我不会再向服务器发送信息,但是服务器还可以继续向我发送数据, 最后服务器也发送Fin请求并收到  
主动关闭方在接收到对方的Fin请求后会等待2*MSL的时间后才会关闭(MSL：TCP包在链路中最大生存时间) 如果在收到对方Fin请求后直接关闭,另外一个服务正好使用了这个端口  
建立了TCP连接, 正好上一个连接中有一个请求由于网络原因现在才到达目的地 就会导致另外一个服务收到莫名的请求  

Ack后 TCP连接才算释放  
超时重传：字面意思 超过一定时间没收到Ack后就会对数据进行重传  
累计确认重传：例如  当接收到第100字节的数据时 接收方发现seq 已经是100 但是seq 1 还没有收到 他就会发送 ack ==1 的请求3次来表明 seq1的数据还未收到  
sack选择性重传：对累计确认重传的改进。以前的累计确认重传丢包重传的效率低，当 1-100个字节分10组时 1-10 丢包后需要重传所有数据,有了sack可以明确哪些包
需要重传。  
流量控制：每次发送请求方都会带上窗口大小告诉接收方当前的缓冲区大小,接收方也会在ack请求中告诉发送方自己的窗口大小(需要乘上缩放系数,在建立连接时互换过数据)  
拥塞控制： 慢启动 流量避免 快速重传 快速恢复
UDP：无连接 协议内容 ： 源端口 目标端口   报文长度（不是必须，凑字节?） 校验和（不是必须， 应该是给接收方做验证使用）  
OSI：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层  
路由器：用于连接两个不同网段  工作在网络层  网关   
交换机：全双工 连接同一个网段  智能 会记录IP表  
网桥：半双工通信 连接同一个网段  
中继器：连接同一个网段,但每次都需要广播消息 不够智能而且是单工通信  
子网划分：192.168.1.1/24   24表示子网掩码为（255.255.255.0）即24个1   与192.168.1.1 进行 &操作后得到192.168.1.0 为网段IP
相同网段才能通信 , 192.168.1.2/24 进行&操作后 为192.168.1.0  网段相同 所以能够通信。一共由256个IP ，除去 0和255两个特殊IP
一共254个IP,  为了有效利用IP 可以进行子网划分。 192.168.1.0/25  此时就被划分成了两个网段 一个是 192.168.1.0 一个是192.168.1.128
控制网段的范围 有效利用资源 
KCP: 纯算法实现的一套快速可靠ARQ协议,不负责底层通讯协议,通常与UDP配合使用。
以牺牲部分带宽来提高传输速度。
主要特性有
1.超时重传时间是RTT*1.5
2.选择重选
3.快速重传 例如发送 1 2 3 4 5 五个包, 陆续收到1 3 4 5之后 kcp知道2被跳过了三次,则不需要等待超时重传时间，直接进行重传
4.延时ACK和非延时ACK
5.UNA和 ACK+UNA: ARQ响应模型有两种， 1.UNA 此编号前的包都收到和 ACK 该编号包收到
6.非退让流控 1.发送窗口由发送窗口缓存,接受端剩余大小,丢包退让和满启动决定,但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率为代价，换取流畅传输的效果。
KCP 流程: 
KCP.Send() => KCP内部处理后 => KCP.Output() => UDP.Send() 

UDP.Receive() => 自己做处理 recv() => KCP.Input() 接受的时候需要处理消息分片处理完会放入队列中recv_queue => 用户调用kcp.recv获取数据 
