Require
ToLua中会在package的searchers中又加了一个加载器 这个加载器是C层的一个方法
如何管理好每个界面的资源
用BuildAssetBundles的方式去打ab包时,每个资源都会去找相关依赖的资源是否有ab名，如果有的话会直接把依赖资源打成ab包，及时你并没有去打这个依赖资源。
如果这个依赖资源并没有相关ab信息的话就会直接把这个依赖打进目标ab包中。
特效
1.GC的触发机制
2.GC的清理机制
3.GC的一些相关配置

C# GC是基于“代”的概念，C#的GC会在代满的时候触发GC，并将最后幸存下来的对象放置到上一代，久而久之第2代（祖先）的对象会更加稳定。
遍历所有堆栈中的局部变量，方法参数，静态变量是否引用了对象，是的话就把同步位索引设置成0
垃圾回收时会暂停所有线程 和Lua不同所有他们用了不同的GC算法  两色标记 和 三色标记  
lua在5.0之前使用简单的扫描标记清除没有引用的对象 这样做会把整个虚拟机的table遍历一遍会导致 stop the world,非常影响性能和卡顿,5.1用了步进器收集器
大致就是gc会按照步骤进行回收,不会一次性进行一次完整的垃圾回收,从而导致卡顿,5.1新增了两个概念，间歇率和步进倍率,
间歇率来控制两次完整Gc的间隔,它是根据上一次内存使用量为基准 判断下一次内存使用量达到某一个倍率时会触发，比如200 就是达到上一次的2倍
步进器倍率是指每一步执行速度的间隔,是收集器运作速度相对于内存分配速度的倍率

Git原理:  分布式,每台终端自成系统,不像SVN如果服务器坏了数据就没了,git只要有一个人的版本仓库 就可以恢复。
所以git可以在本地进行修改和提交(因为本地存在版本仓库),后续有网络之后在进行推送。
Git的每次提交都会生成版本快照,不同于其他中心控制的版本管理,例如SVN P4 记录每一次提交的改动。
首先Git 将文件放到暂存区,会对每个文件生成Blob(记录文件信息) 并按Sha-1生成哈希值。
然后git 进行 Commit操作,会对文件所在目录生成哈希值 存储他们作为一个tree object(树对象)并包含了该目录下的文件blob
最后会生成一个Commit object 记录对应tree的指针,提交人信息 作者等,并包含上一次提交的指针
建立一个分支就是增加一个指针,远程仓库在本地也是一个无法更改的指针,当进行pull时会更新这个指针的位置

有栈协程和无栈协商的区别是能否挂起一个嵌套函数。
行为树:由控制节点,行为节点,前提条件组成,控制节点主要是用来做决策行为,行为节点是决策的结果,控制节点的决策有选择,序列,并行三种方式,如果前提条件满足则转移。
状态机:由状态,条件,转移,动作组成。
两者区别: 行为树能够处理更加复杂的情况,状态机在复杂情况下难以维护。比如n个状态 状态机就最多就有n*n中状态转移,我很难知道我为什么在这个状态即状态的上下文会变得难以追溯。
1.行为树的灵活性比较强,状态机无法同时处理两个状态而行为树可以。 但在少数状态时,状态机还易于维护,就显得比较方便,而行为树就稍显繁琐,因为每次都需要增加控制节点
2.行为树可以简单的对当前状态做出各种反应,但是状态机需要花费大量状态和状态转移

经常会把位运算中左移右移的概念搞反，原因可能是没理解高位在后，低位在前，比如 1000000 常常把这个值当成是1 其实这是一个非常大的值，应该是00000001
原码补码反码是计算机计算负数用的一种编码。
计算机中的数在内存中都是以补码表示的, 所以 ^1 等于 -2    0000 0001 => 1111 1110 => 需要将补码转化为原码 => 1111 1101 (反码) => 1000 0010 (原码)
float 和double的存储方式: sign + 指数位 + 尾数 0.125 -->0.001 -> 0*1/2 + 0 * 1/4 * 1 * 1/8   
0.125 => 0.001 (十进制转二进制 一直乘2 直到值为1 , 按顺序取第一位数)  0.125*2 =  0.250  0.25 * 2 = 0.5  0.5*2 = 1  所以为0.001 
1.125 => 1.001
-128~127 -128表示 10000000 特殊规则
0.1+0.2!=0.3 :  想要知道原因首先得知道0.1和0.2在计算机内存中的表示方式,0.1的二进制为 0.2 0.4 0.8 1.6 (0.6 * 2=1.2) (0.2 * 2=0.4) =>0.00011001100110011... 
计算机中无法精确表示0.1的值,所以直到占满所有尾数位,0.2 也是一样 0.0011001100110011   0.0011 +  0.00011  

C# 调用 Lua 实际上是 C#调用lua的C API 去和Lua交互
Lua 调用 C# 
.net 和mono ： mon是基于.net开源库开发的一个跨平台的实现方案,主要由社群和xamarin维护  .net无法跨平台,.net core 可以
msg 延迟调用 缓存
UI框架:设计了一套完备的UI框架 采用MVC框架 纯lua实现,包含各种生命周期函数 栈实现 命令队列处理ui消息 存储 销毁 框架内几乎所有操作不产生Gc 除了输入产生的数据包,并且支持同时开启多个UI ,能够对控制器进行存储
并且所有逻辑都写在已经定义好的生命周期内,比如一开始需要进行网络请求,结束后请求资源 ,然后设置面板数据等等,并且定义好gameObject后自动生成lua文件,开发者一般只需要在特定的方法内写逻辑即可,效率非常高 PSDImport 然后通过进场入场函数来配置动画资源
protocolbuf 实现 编译器 proto 
pbc 需要准备 pb文件（由proto转换而来）首先需要把pb字节都注册到pbc中 前后端公用的协议ID 分别对应各个协议名  数据结构  四字节 数据大小  四字节 协议id  xxx字节 主要内容
客户端获取到协议ID 然后知道对应的协议再用pbc来解析数据
C#的protobuf解析分析：在将proto编译成cs文件时，编译器会直接把固定的序列化反序列硬编码到方法中，通过tag来区分不同的字段

战斗准备工作 
1.加载两边阵容的模型预制 动画 音效 特效 统一处理所有模型依赖到的资源
Hero : buff Hp animator  
BattleManager管理heros 

PlayMaker 一个状态机 继承Mono 挂载在游戏物体上， 给游戏对象赋予了状态的概念，可以对各种状态进行各种逻辑处理（Action）及在不同状态之间的逻辑转换（Event）

UIRoot:Content Width  Content Height  设备分辨率会通过这个分辨率来计算出一个基于这个分辨率的分辨率来适应UI，说白了就是让设备分辨率接近游戏设置的分辨率，让他们看起来不要差太多

批处理一般用于静态物体，只需要进行一次合并然后把数据提交给GPU就结束了，但是动态物体每帧都需要渲染，所以每帧都需要提交drawcall给GPU就导致了每帧CPU都需要大量的运算合并
一次drawcall,GPU会使用相同的渲染状态来绘制，所以批处理的物体必须是相同的渲染状态


协程同步调用 SetShaderColor 

... 只能放在参数末尾，否则是提取第一个参数
lua ...表示可变参数 function Test(...) Test(1,2,3) 那么这个...就代表 1,2,3  
 local a,b,c = ...   会分别赋值给a,b,c   local a = ... 则 a = 1

游戏中的红点系统
实现内容
1.所有红点动态生成，数据改变能改及时刷新当前显示中的红点
思路一.
通过注册所有红点事件 参数1 生成红点的父物体 参数2 是否生成红点的func  不显示时移除注册
刷新红点的方式1. 数据改变通过广播的方式来刷新 但是得处理每一条红点数据  方式2.通过update每帧刷新当前注册且显示的红点


Lua Table 简单总结一下Table的用法对应C源码中是如何实现
1. Table的查找 t[1] t[1.2] t["xx"] t[func] ..
ltable luaH_get 首先会判断key的类型，若key是整型并且在数组的范围之内会直接返回对应数组元素 key-1 就代表lua下标是从1开始
然后其余会根据类型计算hash然后找到对应Node节点，然后比较Node节点中的Key值是否与目标Key值相等，
若相等就直接返回Value，若不相等则在Node的链表上寻找若还是没有该值则返回nil

2. Table的赋值
首先会查找是否有对应的key，若有直接赋值即可，若没有则查看hash表是否有多余的空间，有就存放在hash表中，若没有则会resize数组和hash表（resize只会发生在判断hash的时候）
比如 a={} a[1] = 1   首先lua会去寻找数组中是否存在该key（判断key是否在数组范围内）是的话直接返回该值 但有可能该值为nil。这里的话因为数组大小为0，所以在hash中寻找 显然没找到这时
resize数组和hash表，遍历这两个数组筛选int类型的key，根据下述规则分配元素，先是(0.5,1] a[1] 符合区间 且利用率大于百分之五十，所以扩张数组到1再因为 int元素为1 > 1 / 2 继续循环 (1,2] 元素为0
数组大小还是为1，  1 == 2 / 2 跳出循环， 最终数组大小为1 
数组中的key不一定是按照从1按顺序排序，数组大小是根据 所有值总数 根据区间超过利用率百分之五十来判断
3. Table的resize规则: 
	array：
	table会计算array中所有元素的数量和node中number类型的元素的数量的总和
	在计算每个区间内（2^(i - 1) + 1 , 2^i）的元素数量，一般情况下 size由array的元素决定
4. ipair  --ipairs 返回了三个值给 for 循环来进行迭代: 迭代函数, 迭代对象 (函数的第一个参数), 以及迭代初始值 0。迭代函数 ipairsaux
ipair只是简单的每次增加1 然后返回相应的值 若遇到nil则停止迭代

5. pairs 会先去寻找元方法_pairs，若找到了则直接带上迭代只执行元方法，否则会先去数组中寻找迭代值是否在范围内，若是就返回并且每次
+1来迭代，若为空则调用C方法来进行迭代,与ipair相同 返回三个参数 迭代函数，迭代对象（函数的第一个参数），以及迭代值初始值为nil
6.# ,luaH_getn :  
1.如果数组部分的size下标(即arr[size-1])为nil,则对这个区间进行二分查找。 
2.如果数组部分的size下标(即arr[size-1])不会空(即刚好被占满),并且哈希部分为空,则直接返回size
3.如果数组部分的size下标(即arr[size-1])不会空(即刚好被占满),并且哈希部分不为空,则以两倍的速率来查找hash表,比如size为8,那么会去查9是否
不会空,如果不会空,则去查找18, 如果18为空,则在9-18 之间做二分查找。
print(#{nil,nil,0}) => 3       这种初始化赋值的方式 虚拟机会一开始就进行长度的计数
local t = {1,2,3}; t[2] = nil; print(#t) => 3    t[2] = nil   只会单纯将 t[2] 置为空
local t = {1,2,3}; t[2] = nil; t["x"] = nil; print(#t) => 1 t["x"] 引发rehash  会移除所有的nil数据 array part： 1 hash part 3
local t = {1,2,3,4,5,6,7,8}; t[16] = 0; print(#t) => 16 
local t = {1,2,3,4,5,6,7,8}; t[15] = 0; print(#t) => 8
解决hash冲突的方式
2.1 开放定址法
2.1.1 线行探查法
2.1.2 平方探查法
2.1.3 双散列函数探查法
2.2 链地址法（拉链法）
2.3 再哈希法
2.4 建立公共溢出区

透明度混合必须得关闭深度写入，并且在不透明物渲染后渲染。
如果开启深度写入，在透明物后面的物体不会被渲染，主要是因为透明物可以看到其后面物体的差别

图像渲染中 每个顶点的渲染在哪个坐标空间并不重要，重要的是其他信息（如视图方向，灯光方向）也要转换到相应的空间，每个顶点都应该接受光照的处理
每次都会把uv的概念搞混,这次好好记录一下。  模型上面的uv 其实和贴图上的uv是一一对应的，知道两个模型的uv就可以知道他们之间的所有uv坐标，从而就可以从uv对应的贴图像素填充到模型上，而模型上的uv又对应相应的顶点。

最近写了一个无限列表，但是遇到一个问题：在滑动的过程中按压滑动和通过惯性滑动表现的效果不太一样，惯性滑动能够正常滑动，但是在条目改变位置时进行滑动会一帧切到下一个目标，原因是按压滑动的过程中我改变了Content的坐标，但是ScrollRect滑动是通过起始的按压位置然后根据鼠标的偏移来计算滑动坐标，所以改变Content的坐标并不能改变ScrollRect的起始按压位置,所以下一帧Content的位置又会回到原来的偏移位置。

总计一下为什么C调用Lua这么简单，Lua调用C相对就比较麻烦。
Lua是一个嵌入式语言，他可以很容易的嵌入到其他语言中（宿主语言）它是由C语言开发，因此它可以很容易得被C调用,它包含了许多C函数。
Lua调用C：想象一下C是一个大圈，Lua是一个在大圈中的小圈，Lua想要调用他的宿主那必然得经过许可登记。Lua中没有关于C的信息，简单说,C中有Lua虚拟机，因此可以虚拟机这个桥梁来控制Lua。
Lua调用C/C#的两个重点是1.C/C#得把Lua虚拟栈中的参数转换成方法需要的类型 2.如果有返回值，要把返回值压回栈中。
在Lua中调用的C#对象的不管是字段，属性还是方法在虚拟机中都是有登记的，都对应一个方法，不过没有登记那么就访问不到
所有Lua类型参数传到C#中都会经过转换,具体规则可以自己定制
Lua调用C#方法都是通过函数指针为依据
tolua同时能打印lua层和C#层堆栈其实就是在C#层调用了一个结合Lua和C#堆栈信息的字符串的方法，lua中通过debug.traceback打印堆栈信息，C#通过StackTrace打印堆栈信息
tolua会对调用GetFunction的方法进行弱引用缓存,因此项目中改该方法的代码会导致失效

进场动画会导致很多位置偏移,很多地方会出现问题 项目坑
不同版本的protobuf可以互相序列化和反序列化,即跨平台 
protobuf编译:把proto编译成不同语言的脚本,然后再用脚本中的接口来序列化和反序列化
#define luaL_newlib(L ,reg) luaL_register(L,"protobuf.c",reg)  tolua中C#在lua虚拟机中已经注册了protobuf.c，因此lua中可以直接require "protobuf.c"

当...作为实参时，后面跟有参数，则...只读取第一个参数

关于时间的几点需求： 
heroTime依赖battleTime依赖globalTime(感觉不用也行 可以直接用Time.timeScale=0)
1.全局暂停和开始 可直接用Unity时间接口
2.局部暂停 如一个英雄放技能 其他英雄暂停 (特效,动画)
3.一个英雄放技能 所有英雄都暂停 但不影响UI

学会总结。
世界坐标Position 其实也是相对摄像机来说的， 就像两个摄像机中同一个位置的Position是不同的。 所以矩阵转换的方法会和camera有关


C#Lambda的一些理解 ： 使用lambda一般会生成一个嵌套类 用来存储方法和外部变量 然后将方法指针返回给委托
引用了外部变量的lambda和没有引用外部变量的lambda会生成不同的嵌套类(没有外部变量直接静态构造函数中实例化详细见IL)，外部变量会被嵌套类记录，查看IL发现
在一个方法中局部变量在IL中都是通过嵌套类的变量来使用的,因此当改变局部变量时在IL中就是改变了嵌套类中的变量
在同一个方法中 所有lambda(有外部变量和无外部变量)的嵌套类对象都是共享的。
   int bc = 1;
   Action act = () => { Console.WriteLine("222" + bc); bc = 2; };
   Action<int, int> act1 = (a, b) => {Console.WriteLine("222" + bc); };
结果为: 2221     2222 
当Lambda语句相同时嵌套类只会有一个对应的函数,Action委托中都只是存了相同的指针
一个很经典的例子：  
	Action[] b = new Action[5];
	for (int i = 0; i < 5; i++)
	{
		b[i] = () => { Console.WriteLine("111" + i); };
	}
结果都为 1114 因为他们共享了相同的对象和指针 所以i都是4,一种高级的用法就是在语句中改变变量的值.
有一个很经典的例子：
	Action[] b = new Action[5];
	for (int i = 0; i < 5; i++)
	{
		int index = i;
		b[i] = () => { Console.WriteLine("111" + index);  };
	}
结果为 1110,1111,1112,1113,1114
如果是这样写的话 编译器会为每个lambda表达式都构造一个对象并存入每一个index的值
public delegate void MessageGet();  内部解析：MessageGet其实是一个内嵌类 继承Delegate 
MessageGet messageGet;  声明一个MessageGet类型的变量 
messageGet = () => { Console.WriteLine("111111"); }; lambda用自己内嵌类对象和对象的方法指针
作为参数构造了一个MessageGet对象,调用时其实就是通过方法的指针
messageGet()  == messageGet.Invoke()
public event MessageGet name;
当定义事件时,会生成一个私有的委托变量和一个公开的事件类型变量,并且生成两个方法add和remove
事件是对委托的一层封装 
事件是委托类型的成员 委托是类型
事件会为其所在的类中增加remove和add两个方法 对应 -= +=  
事件成员在其class外部不能使用invoke 即调用方法（只能使用+= 或者-= 不能进行其他操作 比如= 赋值操作） 因为委托是私有变量,所以外部无法调用
事件能够增加安全性 暴露的接口少

简单的看了Dictionary的实现：Dictionary有两个核心的变量 一个叫 buckets 用来存储真正的key所对应的下标，
一个叫entries,是一个结构体数组 存储了哈希值 key value next(下一个index) ,当往字典中插入时，key会进行
哈希运算 int num = this.comparer.GetHashCode(key) & 0x7fff_ffff; 
int index = num % this.buckets.Length; 
再用index去buckets用寻找真正的下标代入到entries中如果key正好和所需的key相同就返回，否则继续从next中遍历

NGUI Panel >>>>>> 简单看了一下NGUI的渲染,最主要的类是一个UIDrawCall,继承MonoBehaviour,其实是一个游戏物体,只不过
被隐藏了,当初觉得所有继承widget的组件其实很奇怪因为他们没有材质没有Render那怎么能渲染出东西呢,其实渲染的工作
都在DrawCall上,Panel会对所有他底下的Widget进行depth升序,然后进行循环遍历如果连续的两个widget的shader material texture
相同,那么会合并mesh,这个工作交给UIDrawCall完成.

Render SetPropertyBlock  在项目中多次遇到bug都是因为这个方法会重新设置shader的属性 想要增加改动必须先获取到PropertyBlock
在该对象上进行增加删除

UI框架:音效系统 封装点击按钮 增加声音字段
项目中的动画播放运行在每帧的时间上,若那一帧的时间过长很容易会出现bug 如动画不播放
只要调用过render.material,那材质球就会替换成material instance 在编辑器中的话就会丢失

一帧中的执行顺序。
C/S逻辑层共用一套C#代码,客户端通过 csharp.lua 转换成lua运行,好处是可以用C#来开发且可以热更新整个战斗模块。战斗使用ECS处理英雄的各种操作。ModelComponent负责英雄在界面上的显示。ProcessSystem是英雄的状态机,控制英雄的行为。每个状态都由一个独立的lua文件来控制。逻辑层的状态改变会通过协议的形式分发到表现层，表现层通过不同的协议进行处理。动画攻击，蓄力点通过工具导出每个动画的打点时间来计算。战斗中的每一个组件都会附加一个TimeClock接口用于二倍数制作。



问题 输出 index 和 i 的区别：
a = {}
local index = 0
for i=1,3 do
	local func = function() 
		print(index)
	end
	table.insert(a,func)
	index = index + 1
end

a[1]()
a[2]()
a[3]()

--NGUI通过屏幕宽高计算偏移后的坐标转换成世界坐标再转换成NGUI坐标,此坐标会根据具体屏幕宽高变化,并不是固定44px,因此要进行适配
--重点是屏幕宽高和实际游戏中宽高是不相等的，屏幕宽高44px 换算在实际游戏宽高中不一定是44px
local resultOffset = UnityEngine.Screen.width * 44 / ScreenManger.Get().UIWidth
使用异步来加载资源时应该极小心当时加载完后的一个上下文状态， 因为不是同步操作,所以状态很有可能会发生改变,应该在使用前做好各种判断.

对网络的一些了解：
网络是非常复杂的，可能会出现很多未知的错误，比如在断网和丢包的情况是不一样的，断网时socket会直接抛出异常断开连接，但是丢包时socket不会认为是断网。100%丢包状态下发送一条请求到服务器没发送成功之后重连网络正常后(注意这个时候已经是一个新的socket)上一条请求也可能会被发送出去
2020/12/14 查多倍数战斗敌方怪物莫名消失问题   查了一个下午发现是一个动画问题，因为倍数情况下，一帧的时候变长，导致动画在一帧内就能播放完毕 而这时判断播完已结束 一系列初始化没有执行
记录一个网络底层的bug，已知我们的网络通信是在另外一个线程上的。  在断开路由器而不直接断开wifi的情况下，socket close 会堵塞((((，socket receive 是不会立马抛出异常的 所以就会有一个超时机制 去close socket，但是这种情况就会导致去close socket时另外一个线程会立即触发异常机制，它也会去进行一个close socket 两个线程同时close 就会导致主线程被阻塞，网络线程会完成close

聊一聊困扰了很久的渲染顺序问题(显示先后顺序或者说层级)
一直没搞懂深度测试和UI渲染顺序,以前一直以为不管UI还是3D物体都是通过深度测试来控制层级,其实不一定，如果关闭深度测试或者配置成ztest always那么控制层级的就是提交drawcall的顺序
也就是说NGUI上的depth panel unity的sordorder sordlayer renderq camera的depth都是用来控制drawcall的提交顺序,剩下的都是提交顺序的规则。
NGUI的裁切是通过一个panel的范围归一化 然后将子物体坐标转换到panel坐标系下比较    11


闭包 ：upvalue实际是局部变量，而局部变量是保存在函数堆栈框架上的，所以只要upvalue还没有离开自己的作用域，它就一直生存在函数堆栈上。
这种情况下，闭包将通过指向堆栈上的upvalue的引用来访问它们，一旦upvalue即将离开自己的作用域，在从堆栈上消除之前，闭包就会为它分配空间并保存当前的值，
以后便可通过指向新分配空间的引用来访问该upvalue。当执行到f1(1979)的n　=　n　+　10时，闭包已经创建了，但是变量n并没有离开作用域，
所以闭包仍然引用堆栈上的n，当return　f2完成时，n即将结束生命，此时闭包便将变量n(已经是1989了)复制到自己管理的空间中以便将来访问。 

反射:在运行时获取程序集的元数据进行一系列操作。之前以为反射是会在运行时编译代码其实不,反射的Emit会生成代码所以无法用AOT进行编译
工具:DrawCallCheck, 打表工具,动画数据导出,Jenkins打包,动画系统,
C#协程：
  public  static IEnumerable CorInternal()
{
	yield return 1;
}
协程其实是一个迭代器,调用CorInternal其实会生成一个迭代器的实例对象,C#会根据方法实现生成不同代码的迭代器主要是MoveNext(),
每执行一次yield return其实就是执行了MoveNext(),这个迭代器内部会用一个int保存当前的执行状态,根据这个int来直接跳转到指定的代码
Unity的协程是如何实现的？   我们无法修改C#为我们自动生成的MoveNext,但是我们可以封装一层在获取到Current的时候,通过这个Current(准确来说应该是上一个Current)
下一个MoveNext能不能执行。 准确来讲应该是调用MoveNext去判断上一个Current是否允许执行MoveNext

adb forward tcp:34999 localabstract:Unity-com.company.product 真机调试

我知道值类型为啥不需要类型对象了 因为值类型是密封的，没有多态的概念 直接去查元数据就好了， 引用类型会有不确定的继承关系

C++ 指针和引用: 概念上来区别 指针是一个类型,引用只是一个别名。在实现上 引用相当于一个受限的指针,它无法主动进行 *(dereferencing )获取内容和referencing ,并且
必须得声明时就初始化,之后无法改变 int number1 = 1, int number2 = 2 , int& pNumber1 = number1(必须得初始化,否则编译器报错), pNumber1 = &number2 (报错,无法改变)
pNumber1 = number2 (可以,把number2的值赋值给了number1 ,因为pNumber1只不过是number1的一个别名)
.refer to https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html
C++ C# Const 不同的是 C++ 指针地址所指向的内容无法改变,即 *pNumber1 = 2 是无效的, 但是 pNumber1 = &pNumber2 确实有效的, 引用的话内容本身就是无法改变
如果加了const 则内容和指针地址指向的内容都无法改变。
C++ const 分两种情况,1. const int* pNumber 2. int* const pNumber , 
第一种是无法改变pNumber的指针指向的内容,但是可以改变 pNumber的指向（即 *pNumber = 2 错误 pNumber = &number2 正确）
第二种是无法改变pNumber的指向,但是可以改变pNumber的指针指向的内容(即 *pNumber = 2 正确 pNumber =&number2 错误)
C++ 引用则本身特性就无法改变引用,但是可以改变引用的内容，增加了const,则引用内容和引用都无法改变。
 C#的引用只针对变量所存储的地址是无法改变的,但是却可以改变地址指向的对象的内容

闪退的几种原因:
1.底层报错,比如第三方C++库
2.资源问题导致unity底层异常的闪退,这个问题就非常广泛,之前遇到过资源名见有空格会导致偶发闪退
3.unity自身bug导致
Unity相关测试方法：UnityEngine.Diagnostics.Utils.ForceCrash
调试真机闪退的方式 如果development勾选的话 包中会自带调试信息 ，如果没有勾选的话需要导出symbols调试文件,当遇到奔溃时 通过arm-linux-androideabi-addr2line -f -C -e   /Applications/Unity.app/Content/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Symbols/armeabi-v7a/libunity.sym.so 0043a05c 来查看堆栈信息

unity Bound结构

UGUI 框架源码阅读记录:
事件系统:
PointerEventData 对应鼠标来说 通过延迟创建的方式实例，每个按钮对应一个pointdata,并且每帧都会更新
IPointerExitHandler IPointerEnterHandler 关于这两个接口 进入和退出是指 层级,就是说两者通用的父类到自身之间的所有实现该接口的UI都会调用
一次点击事件的流程：EventSystem类每帧都会驱动输入模块执行,也就是说PointEventData每帧都会刷新数据,比如没有点击时也会刷新位置信息
点击时则会通知EventSystem去进行射线检测,EventSystem再通知Raycaster进行真正的射线检测,第一个检测点就会被记录到PointEvetnData中待使用
PointEventData都填充完毕之后就会处理事件,比如按压 拖拽 移动等,PointEventData是鼠标数据, MouseState 则保存了每个鼠标按键的状态。比如这帧是否进行了点击

UI框架:
pixelsPerUnit ReferencePixelsPer 默认都是100 那么最终Unit：Pixels = 1，如果 pixelperunit = 10 相当于一个单元只有十个像素,那么显示上就大了十倍 通过SetNativeSize可以测试
RectTransform
Rect  左下角为坐标原点  center为中心点
布局系统: ILayoutElement 想要生效必须有一个或者以上的ILayoutController。
LayoutRebuilder:dirty时会将gameobject包装到该类中,然后通过该类进行rebuild,该类有对象池获取,build分为计算布局属性和设置属性部分
计算时先计算子节点再结算父节点以保证结果的正确性
一次自动布局的流程:setdirty()后进入队列等待布局, 在Canvas被渲染前调用,循环rebuild每个ICanvasElement,先计算gameobject的布局属性 (MinHeight PreferHeight FixeibleHeight
该属性由ILayoutElement接口实现,比如Text Min 总是为 0 Prefer 总是等于内容的size,  因此使用ContentSizeFitter 控制器就可以根据内容的大小来自适应控制size)
然后调用 控制器的 SetLayoutHorizontal SetLayoutVertical 来设置 自身或者是child的 属性
ChildControlsSize:控制子节点的大小在MinHeight 和PreferHeight 之间 比如如果父节点的Height足够,那么会用PreferHeight,如果还有多余空间则根据子节点Fixeible的权重来分配剩余空间
ChildForceExpand:将所有子节点均匀占满整个区域  如果ChildControlsSize开启则会拉伸
Cull 和 Mask的区别:Cull 只是用Rect对一个矩阵区域进行裁剪,Mask使用模板测试剔除alpha为0的部分
Cull和Clip 剔除和裁剪都是clipper算出rect后调用CanvasRender接口
Mask 模块测试的实现: 嵌套mask和单mask区别不太一样,嵌套mask要复杂需要. 单mask 只需要 always ref 随便 
嵌套Mask   
Ref WriteMask ReadMask
1        255    255
3        3         1
7        7         3
嵌套Mask  需要先比较模板值通过后 改变每一层的模块值  读取时需要读上一层的模板值, 因为在嵌套Mask里一定会显示子Mask(如果父Mask有模板值)(只有有像素的地方才会有模板值)
Mask DrawCall 合批:
性质1：Mask会在首尾（首=Mask节点，尾=Mask节点下的孩子遍历完后）多出两个drawcall，多个Mask间如果符合合批条件这两个drawcall可以对应合批（mask1 的首 和 mask2 的首合；mask1 的尾 和 mask2 的尾合。首尾不能合）
性质2：计算depth的时候，当遍历到一个Mask的首，把它当做一个不可合批的UI节点看待，但注意可以作为其孩子UI节点的bottomUI。
性质3：Mask内的UI节点和非Mask外的UI节点不能合批，但多个Mask内的UI节点间如果符合合批条件，可以合批。
原理是 不同层级的UI使用了不用版本的模板材质,只要模板信息相同就会使用相同的材质 自然就能合批,Mask外的UI节点之所以不能和里面的合批是因为使用的材质本身就不同
RectMask2D
RectMask2D不需要依赖一个Image组件，其裁剪区域就是它的RectTransform的rect大小.
性质1：RectMask2D节点下的所有孩子都不能与外界UI节点合批且多个RectMask2D之间不能合批。
性质2：计算depth的时候，所有的RectMask2D都按一般UI节点看待，只是它没有CanvasRenderer组件，不能看做任何UI控件的bottomUI。
原理是 Shader中RectClip裁剪区域不同,挂在RectMask2D上的Image能合批是因为没有裁剪区域
ShowMaskGraphic ColorMask 0

Static Batch   Dynamic Batch  GPU Instance : 
共享相同的材质
Dynamic Batch:
1，900个顶点以下的模型。
2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。
3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。
4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。
5，合并网格的材质球的实例必须相同。即材质球属性不能被区分对待，材质球对象实例必须是同一个。
6，如果他们有Lightmap数据，必须相同的才有机会合批。
7，使用多个pass的Shader是绝对不会被合批。因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。
8，延迟渲染是无法被合批。
Static Batch:设置了静态合批选项后会在打包时将所有静态合批对象的Mesh合成一个Mesh保存起来,但必须使用相同材质
GPU Instance:必须使用相同Mesh和Material,原理只不过是使用不用的Per-Instance data来处理不同材质,需要使用特殊方法来标记,并不是进行合批操作,不过确实能减少drawcall。
GPU Instance原理:CPU 只需要把Mesh 和 Material 和 一个包含实例数据的数组交给GPU ,GPU就会进行相应处理。这个过程CPU 只需要和GPU进行一次,只需要一个drawcall。
UNITY_INSTANCING_BUFFER_START(Props)
           UNITY_DEFINE_INSTANCED_PROP(fixed4, _Color)
UNITY_INSTANCING_BUFFER_END(Props)

UNITY_ACCESS_INSTANCED_PROP(Props, _Color);

万向节死锁:两条轴共面导致,理论: unity中旋转的顺序是(y-x-z),y是随着惯性坐标轴旋转,x和z 都是随着模型坐标轴旋转, 所以当某一个时刻(比如x旋转90°) ,两个轴平行共面,导致失去了一个方向的旋转

Addressables学习心得:  AddressableAssetEntry 是group中每个asset的封装
class son : father
virtul eat   void run
father= new son()  eat()  run()   首先判断father变量的类型 如果方法是虚函数 则执行实际类型的函数,如果没有就往上代回溯。如果方法不是虚函数,则执行变量类型的函数,如果没有就向上代回溯

RPG:  
第三人称镜头问题：一般在人身上挂一个摄像头(假设是挂在父节点A下面),那么当人物移动,那父节点就会移动,摄像头就会移动。 水平方向的鼠标输入控制A的Y轴旋转,垂直方向控制A的X轴旋转。
然后根据A的坐标来控制移动的方向, 正前方就是A的X轴正方向

UnityEditor记录：EditorWindow 可以自定义一个窗口, Editor 主要是用来对Inspector面板上的某个组件进行编辑,通常配合CustomEditor特性一起使用
GUI 和 GUILayout : GUI 是固定布局,GUILayout是自动布局  EditorGUI和EditorGUILayout只能使用在编辑器种,无法在游戏中使用

A* 算法:启发式函数 f(n) = g(n) + h(n) ,g(n) 代表n节点到起点的代价, h(n)代表一个从n节点到终点的最佳路径的代价的估算函数。
1.初始化: 以f(n)为基准初始化一个最小堆或者是优先队列,openset,一开始只有一个节点即起点, 和一个hash字典存储每个节点的g(n),起点为0. 和一个节点之间的一个关系comeFrom,key为目标节点,value为目标节点的父节点
2.核心算法: 循环遍历节点,直到找到终点,或者没有节点。设当前节点为f(n)最小的节点设为A,对周围节点设为B进行如下操作：首先先从openset中移除A保证下一轮循环不会出现。判断从A出发到B的g(n)是否比原来更小,如果是的话就更新B的f(n)和g(n)
然后设置comeFrom[B] = A即A是B指向的路径,最后如果B还没有在openset中,就将其加入。这就是一个循环的流程。
h(n)有两个属性,1.admissable 可接纳性 2.consistent 一致性。 
admissable需要保证估算函数不能高估到达终点的代价,这会导致无法找到最优路径
consistent 假设   N h(N)---S       那么 h(N) <=  c(N,N') + h(N')        设S为终点, h(S)为0 , h(NA) <= C(N,S) + 0 即满足admissable
                c(N,N') |          /
                            |        /
                            |      /
                            |    /
                            N'  h(N')  
refer to https://en.wikipedia.org/wiki/A*_search_algorithm

Prime算法:寻找最小生成树即 能连同所有节点并且权值和最小的树, 采用贪心算法 首先随便取一个节点放入容器中,然后寻找与姐容器内节点相邻
的权值最小的边加入到 边容器中(要剔除边的另外一个已经加入到容器中的节点)一直循环该操作,直到所有节点都遍历完毕, 边容器中的就是最小生成树的边

四叉树 八叉树 快速碰撞检测 GPUInstance  
GPUInstanceAnim https://github.com/chenjd/Render-Crowd-Of-Animated-Characters  对动画信息进行采样生成到贴图当中,在GPU中做uv动画

导入资源 使用脚本自动设置 对象池 unity自身函数
对象池 资源压缩(贴图 音频 网格 材质) drawcall 
降低分辨率 拆分透明通道 crunch comporession mipmap  lod
内存换CPU  多线程 ECS 

渲染管线:主要分三个阶段 
1.应用阶段  主要是以CPU主导,在场景中改变各种图元的属性,后续CPU将这些图元信息传递给GPU。
2.几何阶段  主要是将顶点的模型空间转换为设备坐标。顶点着色器函数可以处理顶点的属性,比如做一些动画 改变颜色等,然后将进行投影即转换成
齐次空间坐标进行裁剪,最后转换成设备坐标。
3.光栅化阶段 该阶段的像素称之为片元(fragment),因为这个时候还没有完全成为像素。
在三角形设置和遍历之后会调用片元着色器并对图元内的像

进行插值,片元着色器可以使用从顶点着色器带来的数据
最后会进行各种测试 比如模板测试 深度测试 等,由于性能问题, 也有一些技术 比如 Early-Z 可以提前深度测试 从而减少不必要的操作
最后通过前置缓冲和后置缓冲的切换来将像素呈现在屏幕上。

资源优化: Crunch Compression : 优点 减少资源大小 减少硬盘使用空间 提高下载速度  缺点是在编辑器中压缩时间过长。 
在unity 2017版本中增加了可以对ETC ETC2 DXT继续压缩  支持了android 和ios中的使用。 对ETC压缩后的资源进行 Crunch压缩, 解压后就是ETC压缩资源
DXT1:将像素分成4*4的块,每个块包含 两个极端颜色 （每个颜色占16位, 其余颜色通过插值计算）和32位索引,每个像素2位,不包含alpha。
DXT2,DXT3: 在DXT1的基础上增加了64位来表示alpha信息,每个像素4位表示alpha, DXT2 预先乘上了alpha  DXT3则没有预先乘上。预先乘上可以减少透明混合时的额外计算 适用于有明显透明变化
DXT4,DXT5:在DXT1的基础上增加了64位来表示alpha信息,与DXT2 3不同的是 DXT4 5将alpha也分成了两个8位的极值,和3位的索引 通过插值来计算每位alpha, DXT4是预先计算alpha,DXT5没有预先计算 适用于缓慢的透明变化
Ericsson Texture Compression (ETC): 和DXT一样 4*4为一个块 一共64位,  又分成了两个子块 2*4 由flip位来控制是竖直划分还是水平划分。
每个子块有一个3位的修饰表索引代表了8组偏移和一个基本颜色块 (2*R4G4B4 或者 R5G5B5+R3G3B3) 每个像素由有一个选择器数据来选择哪组颜色
两个子块 base color 2*12 + 1diff位(控制子块的颜色类型) + 1flip(控制方向) +  2*3 修饰索引 +  16*2 每个像素两位索引器
Adaptive scalable texture compression (ASTC): 支持不同块大小
PVRTC (PowerVR Texture Compression):由两张缩小4倍的图和一张调制图像进行线性插值
AssetBundle.Unload(flase)是释放AssetBundle文件的内存镜像，不包含Load创建的Asset内存对象。
AssetBundle.Unload(true)是释放那个AssetBundle文件内存镜像和并销毁所有用Load创建的Asset内存对象。

帧同步:客户端进行计算,客户端将操作发送给服务器,服务器按照固定的逻辑帧同步给其他客户端。 

协变(covariance)和逆变(contravariance): 是指类型构造器构造出的多个复杂类型之间的父子关系。 
例如数组 car[] 和 animal[] ，泛型 委托和接口Action<Parent> 和 Action<Son> 。
协变是保持了子类型和基类型的关系 子类型<=基类型 
逆变是逆转了子类型序关系
 