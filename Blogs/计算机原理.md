1. 经常会把位运算中左移右移的概念搞反，原因可能是没理解高位在后，低位在前，比如 1000000 常常把这个值当成是1 其实这是一个非常大的值，应该是00000001
原码补码反码是计算机计算负数用的一种编码。
计算机中的数在内存中都是以补码表示的, 所以 ^1 等于 -2    0000 0001 => 1111 1110 => 需要将补码转化为原码 => 1111 1101 (反码) => 1000 0010 (原码)
float 和double的存储方式: sign + 指数位 + 尾数 0.125 -->0.001 -> 0*1/2 + 0 * 1/4 * 1 * 1/8   
0.125 => 0.001 (十进制转二进制 一直乘2 直到值为1 , 按顺序取第一位数)  0.125*2 =  0.250  0.25 * 2 = 0.5  0.5*2 = 1  所以为0.001 
1.125 => 1.001
-128~127 -128表示 10000000 特殊规则
0.1+0.2!=0.3 :  想要知道原因首先得知道0.1和0.2在计算机内存中的表示方式,0.1的二进制为 0.2 0.4 0.8 1.6 (0.6 * 2=1.2) (0.2 * 2=0.4) =>0.00011001100110011... 
计算机中无法精确表示0.1的值,所以直到占满所有尾数位,0.2 也是一样 0.0011001100110011   0.0011 +  0.00011  

1. I/O多路复用之select,poll,epoll:三者都是为了在单线程中能够处理多fd, select,poll本质上都是一样的,都是通过将多个fd通过system call注册到内核态,然后在内核态进行轮询,等到有事件到达就返回给用户。这样实现的问题是1.性能开销会随着fd的数量增加而增大,因为每次都需要轮询,每一次注册一个fd等于在重新把所有fd发送到内核态,性能开销大。2.有事件到达时,得需要轮询来获取 3.select的fd数量大小有限制,poll已改进。
后来epoll诞生了,解决了上述的所有问题,不再需要轮询,通过事件回调的方式来通知fd,也不需要每次都注册全部fd,每次增加一个fd,就注册一个fd,通过红黑树结构实现可以快速定位发生事件的fd,并且在增删fd也更加高效