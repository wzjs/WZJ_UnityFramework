# 创建型
 要点: 
 1. 隐藏具体类的信息 
 2. 隐藏这些类实例是如何被创建和放在一起的
 3. 上述其实本质都是在抽象实例化过程,包括类的抽象还有实例化的抽象
 4. 这些类型可以分为类创建型模式(抽象工厂)和对象创建性模式(例如原型)
 5. 本类型以迷宫为例(room,door,wall)
- 抽象工厂(Abstract Factory)  
    意图: 提供一个接口,创建一系列相关的对象,不需要指定他们具体的类,隐藏具体类的实现(实例)细节  
    参与: AbstractFactory,ConcreteFactory,AbstractProduct,ConcreteProduct
    效果: 
    1. 分离了具体的创建产品的类,每个具体类封装了产品的创建,客户和类进行了节藕
    2. 通过切换不同的抽象工厂,可以支持改变产品的风格
    3. 增加新产品比较麻烦,需要对每个抽象工厂都增加该产品,可以对创建产品的方法增加参数(产品类型,产品Idd等)进行动态扩展  

    示例:   

            CreateMaze(MazeFactory factory)
            CreateMaze(EnchantedMazeFactory,factory)
            public class MazeFactory{
                void MakeRoom(){new Room()}
            }
            public class EnchantedMazeFactory{
                void MakeRoom(){new EnchantedRoom()}
            }
    总结: 抽象工厂是一种有点偏结构型的模式，好处能够在不同产品线上切换,但其实他的创建对象还是需要通过工厂模式或者原型来实现。

- Build(生成器) 就像造房子一样,一步一步去构建一个复杂对象
    意图: 将一个复杂对象的构建过程与表示分离,并且可以使同样的构建过程有不同的表示(通过builder子类实现)  
    
    结构: Director，Builder,ConcreteBuilder,Product,
    其中Builder定义了所有构造的接口，子类根据需要实现

    适用型:  
        1. 创建复杂对象的算法独立于该对象的组成部分以及他们的装配方式
        2. 构造过程允许被构造对象有不同的表示

    总结: 一开始以为其实就是在一个对象中通过不同的条件去实例化不同的对象出来,说的也没错,但是从理解上来讲应该是一个复杂对象的构建过程被分为了不同的步骤和对象来表示,例如一个汽车的构建过程包含了电机,车架,轮胎等等,然后根据图纸或者一些步骤去构建出来,不同的汽车可能有不同的Builder,不同的builder有包含不同的实现。感觉其实从对象图上理解使用的范围非常广,但是适用范围还需要认真考虑,builder的思想是一步一步按步骤来构建,精确的控制,而抽象方工厂着重于产品的系列。用得好没问题,用不好理解起来非常难受,对于迷宫来说你说一步一步构造也说得通,但是肯定没有汽车的例子好,再例如一个飞行射击游戏,再来用这种方式来构建就不太合适了。

- Factory Method(工厂方法)  
    意图: 将类的实例化延迟到子类中  
    
    结构: Creator(一般是abstract),ConcreteCreator(不是必须的，可以直接由Creator实现默认),Product,ConcreteProduct

    作用:   
    1. 在对象内部创建要比直接创建对象要灵活, 为Creator子类提供钩子
    2. 连接平行层次的类 ?
    
    实现:   
    1. 有两种情况 Creator不提供默认工厂实现和提供默认工厂实现,第一种方式强制必须得实现不可预见的类？ 第二种增加了灵活性,子类只在必要时重写父类，配合上参数化工厂，实现意想不到的效果。

            class Creator
            {
                public virutal Product Create(int id)
                {
                    if(id == 1){return new Product1();}
                    if(id == 2){return new Product2();}
                    ...
                    return null;
                }
            }

            class ConcreteCreator
            {
                public override Product Create(int id)
                {
                    if(id == 3){return new Product3();}
                    return base.Create(id);
                }
            }

    2. 泛型实现,可以避免创造子类

            class Creator<Product1>{
                public Product Create(){
                    return new Product1();
                }
            }

            class Creator<Product2>{
                public Product Create(){
                    return new Product2();
                }
            }
    总结: 工厂方法常常需要与抽象类一起使用,在抽象类中定义构建方法然后在子类中去实现特定的构造。
    与抽象工厂的区别  
        1. 关注点不通,抽象工厂关注一组产品的创建,工厂方法关注单一铲平的创建
        2. 抽象程度不同,抽象工厂的抽象程度要比工厂方法要高,因为涉及到多个工厂和产品
    
    简单工厂(不再23种设计模式之内)  
        简述: 一般是静态方法,通过参数来创建具体的产品,没有具体的工厂类

        class SimpleFactory {
            public static Product createProduct(String type) 
            {
                if (type.equals("A")) {
                    return new ConcreteProductA();
                } else if (type.equals("B")) {
                    return new ConcreteProductB();
                }
                throw new IllegalArgumentException      ("Invalid product type.");
                }
            }
# 结构型


# 行为型




聚合和组合: 聚合是'has a',例如部门有一个雇员 组合是'contain a',例如人包含了手,脚等