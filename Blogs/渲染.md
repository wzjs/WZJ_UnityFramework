# 渲染笔记
1. 透明度混合必须得关闭深度写入，并且在不透明物渲染后渲染。
如果开启深度写入，在透明物后面的物体不会被渲染，主要是因为透明物可以看到其后面物体的差别

2. 前向渲染和向后渲染：
3. DepthPriming: 先预先渲染一张深度图,在后面进行深度测试时将深度测试改成equal,
4. Early-Z:
5. Z-Prepass:
6. 有ColorAttachment数组,没有Depth数组 原因可能是深度都是固定的, 但是颜色可以不同

7. 图像渲染中 每个顶点的渲染在哪个坐标空间并不重要，重要的是其他信息（如视图方向，灯光方向）也要转换到相应的空间，每个顶点都应该接受光照的处理
每次都会把uv的概念搞混,这次好好记录一下。  模型上面的uv 其实和贴图上的uv是一一对应的，知道两个模型的uv就可以知道他们之间的所有uv坐标，从而就可以从uv对应的贴图像素填充到模型上，而模型上的uv又对应相应的顶点。

8. 聊一聊困扰了很久的渲染顺序问题(显示先后顺序或者说层级)
一直没搞懂深度测试和UI渲染顺序,以前一直以为不管UI还是3D物体都是通过深度测试来控制层级,其实不一定，如果关闭深度测试或者配置成ztest always那么控制层级的就是提交drawcall的顺序
也就是说NGUI上的depth panel unity的sordorder sordlayer renderq camera的depth都是用来控制drawcall的提交顺序,剩下的都是提交顺序的规则。
NGUI的裁切是通过一个panel的范围归一化 然后将子物体坐标转换到panel坐标系下比较 

9. 渲染管线:主要分三个阶段 
1.应用阶段  主要是以CPU主导,在场景中改变各种图元的属性,后续CPU将这些图元信息传递给GPU。
2.几何阶段  主要是将顶点的模型空间转换为设备坐标。顶点着色器函数可以处理顶点的属性,比如做一些动画 改变颜色等,然后将进行投影即转换成
齐次空间坐标进行裁剪,最后转换成设备坐标。
3.光栅化阶段 该阶段的像素称之为片元(fragment),因为这个时候还没有完全成为像素。
在三角形设置和遍历之后会调用片元着色器并对图元内的像

进行插值,片元着色器可以使用从顶点着色器带来的数据
最后会进行各种测试 比如模板测试 深度测试 等,由于性能问题, 也有一些技术 比如 Early-Z 可以提前深度测试 从而减少不必要的操作
最后通过前置缓冲和后置缓冲的切换来将像素呈现在屏幕上。