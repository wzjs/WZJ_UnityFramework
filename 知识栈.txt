Require
ToLua中会在package的searchers中又加了一个加载器 这个加载器是C层的一个方法
如何管理好每个界面的资源
用BuildAssetBundles的方式去打ab包时,每个资源都会去找相关依赖的资源是否有ab名，如果有的话会直接把依赖资源打成ab包，及时你并没有去打这个依赖资源。
如果这个依赖资源并没有相关ab信息的话就会直接把这个依赖打进目标ab包中。
特效
1.GC的触发机制
2.GC的清理机制
3.GC的一些相关配置

C# GC是基于“代”的概念，C#的GC会在代满的时候触发GC，并将最后幸存下来的对象放置到上一代，久而久之第2代（祖先）的对象会更加稳定。 
遍历所有堆栈中的局部变量，方法参数，静态变量是否引用了对象，是的话就把同步位索引设置成0
垃圾回收时会暂停所有线程 和Lua不同所有他们用了不同的GC算法  两色标记 和 三色标记

经常会把位运算中左移右移的概念搞反，原因可能是没理解高位在后，低位在前，比如 1000000 常常把这个值当成是1 其实这是一个非常大的值，应该是00000001

C# 调用 Lua 实际上是 C#调用lua的C API 去和Lua交互
Lua 调用 C# 

msg 延迟调用 缓存

protocolbuf 实现 编译器 proto 
pbc 需要准备 pb文件（由proto转换而来）首先需要把pb字节都注册到pbc中 前后端公用的协议ID 分别对应各个协议名  数据结构  四字节 数据大小  四字节 协议id  xxx字节 主要内容
客户端获取到协议ID 然后知道对应的协议再用pbc来解析数据
C#的protobuf解析分析：在将proto编译成cs文件时，编译器会直接把固定的序列化反序列硬编码到方法中，通过tag来区分不同的字段

战斗准备工作 
1.加载两边阵容的模型预制 动画 音效 特效 统一处理所有模型依赖到的资源
Hero : buff Hp animator  
BattleManager管理heros 

PlayMaker 一个状态机 继承Mono 挂载在游戏物体上， 给游戏对象赋予了状态的概念，可以对各种状态进行各种逻辑处理（Action）及在不同状态之间的逻辑转换（Event）

UIRoot:Content Width  Content Height  设备分辨率会通过这个分辨率来计算出一个基于这个分辨率的分辨率来适应UI，说白了就是让设备分辨率接近游戏设置的分辨率，让他们看起来不要差太多

批处理一般用于静态物体，只需要进行一次合并然后把数据提交给GPU就结束了，但是动态物体每帧都需要渲染，所以每帧都需要提交drawcall给GPU就导致了每帧CPU都需要大量的运算合并
一次drawcall,GPU会使用相同的渲染状态来绘制，所以批处理的物体必须是相同的渲染状态


协程同步调用 SetShaderColor 

... 只能放在参数末尾，否则是提取第一个参数

游戏中的红点系统
实现内容
1.所有红点动态生成，数据改变能改及时刷新当前显示中的红点
思路一.
通过注册所有红点事件 参数1 生成红点的父物体 参数2 是否生成红点的func  不显示时移除注册
刷新红点的方式1. 数据改变通过广播的方式来刷新 但是得处理每一条红点数据  方式2.通过update每帧刷新当前注册且显示的红点


Lua Table 简单总结一下Table的用法对应C源码中是如何实现
1. Table的查找 t[1] t[1.2] t["xx"] t[func] ..
ltable luaH_get 首先会判断key的类型，若key是整型并且在数组的范围之内会直接返回对应数组元素 key-1 就代表lua下标是从1开始
然后其余会根据类型计算hash然后找到对应Node节点，然后比较Node节点中的Key值是否与目标Key值相等，
若相等就直接返回Value，若不相等则在Node的链表上寻找若还是没有该值则返回nil

2. Table的赋值
首先会查找是否有对应的key，若有直接赋值即可，若没有则查看hash表是否有多余的空间，有就存放在hash表中，若没有则会resize数组和hash表（resize只会发生在判断hash的时候）
比如 a={} a[1] = 1   首先lua会去寻找数组中是否存在该key（判断key是否在数组范围内）是的话直接返回该值 但有可能该值为nil。这里的话因为数组大小为0，所以在hash中寻找 显然没找到这时
resize数组和hash表，遍历这两个数组筛选int类型的key，根据下述规则分配元素，先是(0.5,1] a[1] 符合区间 且利用率大于百分之五十，所以扩张数组到1再因为 int元素为1 > 1 / 2 继续循环 (1,2] 元素为0
数组大小还是为1，  1 == 2 / 2 跳出循环， 最终数组大小为1 
3. Table的resize规则: 
	array：
	table会计算array中所有元素的数量和node中number类型的元素的数量的总和
	在计算每个区间内（(2^lg-1,2^lg]）的元素数量，一般情况下 size由array的元素决定
4. ipair  --ipairs 返回了三个值给 for 循环来进行迭代: 迭代函数, 迭代对象 (函数的第一个参数), 以及迭代初始值 0。迭代函数 ipairsaux
ipair只是简单的每次增加1 然后返回相应的值 若遇到nil则停止迭代

5. pairs 会先去寻找元方法_pairs，若找到了则直接带上迭代只执行元方法，否则会先去数组中寻找迭代值是否在范围内，若是就返回并且每次
+1来迭代，若为空则调用C方法来进行迭代,与ipair相同 返回三个参数 迭代函数，迭代对象（函数的第一个参数），以及迭代值初始值为nil


透明度混合必须得关闭深度写入，并且在不透明物渲染后渲染。
如果开启深度写入，在透明物后面的物体不会被渲染，主要是因为透明物可以看到其后面物体的差别

图像渲染中 每个顶点的渲染在哪个坐标空间并不重要，重要的是其他信息（如视图方向，灯光方向）也要转换到相应的空间，每个顶点都应该接受光照的处理
每次都会把uv的概念搞混,这次好好记录一下。  模型上面的uv 其实和贴图上的uv是一一对应的，知道两个模型的uv就可以知道他们之间的所有uv坐标，从而就可以从uv对应的贴图像素填充到模型上，而模型上的uv又对应相应的顶点。

最近写了一个无限列表，但是遇到一个问题：在滑动的过程中按压滑动和通过惯性滑动表现的效果不太一样，惯性滑动能够正常滑动，但是在条目改变位置时进行滑动会一帧切到下一个目标，原因是按压滑动的过程中我改变了Content的坐标，但是ScrollRect滑动是通过起始的按压位置然后根据鼠标的偏移来计算滑动坐标，所以改变Content的坐标并不能改变ScrollRect的起始按压位置,所以下一帧Content的位置又会回到原来的偏移位置。

总计一下为什么C调用Lua这么简单，Lua调用C相对就比较麻烦。
Lua是一个嵌入式语言，他可以很容易的嵌入到其他语言中（宿主语言）它是由C语言开发，因此它可以很容易得被C调用,它包含了许多C函数。
Lua调用C：想象一下C是一个大圈，Lua是一个在大圈中的小圈，Lua想要调用他的宿主那必然得经过许可登记。Lua中没有关于C的信息，简单说,C中有Lua虚拟机，因此可以虚拟机这个桥梁来控制Lua。
Lua调用C/C#的两个重点是1.C/C#得把Lua虚拟栈中的参数转换成方法需要的类型 2.如果有返回值，要把返回值压回栈中。
在Lua中调用的C#对象的不管是字段，属性还是方法在虚拟机中都是有登记的，都对应一个方法，不过没有登记那么就访问不到
所有Lua类型参数传到C#中都会经过转换,具体规则可以自己定制
Lua调用C#方法都是通过函数指针为依据
tolua同时能打印lua层和C#层堆栈其实就是在C#层调用了一个结合Lua和C#堆栈信息的字符串的方法，lua中通过debug.traceback打印堆栈信息，C#通过StackTrace打印堆栈信息
tolua会对调用GetFunction的方法进行弱引用缓存,因此项目中改该方法的代码会导致失效

进场动画会导致很多位置偏移,很多地方会出现问题 项目坑
不同版本的protobuf可以互相序列化和反序列化,即跨平台 
protobuf编译:把proto编译成不同语言的脚本,然后再用脚本中的接口来序列化和反序列化
#define luaL_newlib(L ,reg) luaL_register(L,"protobuf.c",reg)  tolua中C#在lua虚拟机中已经注册了protobuf.c，因此lua中可以直接require "protobuf.c"

当...作为实参时，后面跟有参数，则...只读取第一个参数

关于时间的几点需求： 
heroTime依赖battleTime依赖globalTime(感觉不用也行 可以直接用Time.timeScale=0)
1.全局暂停和开始 可直接用Unity时间接口
2.局部暂停 如一个英雄放技能 其他英雄暂停 (特效,动画)
3.一个英雄放技能 所有英雄都暂停 但不影响UI

学会总结。
世界坐标Position 其实也是相对摄像机来说的， 就像两个摄像机中同一个位置的Position是不同的。 所以矩阵转换的方法会和camera有关


C#Lambda的一些理解 ： 使用lambda一般会生成一个嵌套类 用来存储方法和外部变量 然后将方法指针返回给委托
引用了外部变量的lambda和没有引用外部变量的lambda会生成不同的嵌套类(没有外部变量直接静态构造函数中实例化详细见IL)，外部变量会被嵌套类记录，查看IL发现
在一个方法中局部变量在IL中都是通过嵌套类的变量来使用的,因此当改变局部变量时在IL中就是改变了嵌套类中的变量
在同一个方法中 所有lambda(有外部变量和无外部变量)的嵌套类对象都是共享的。
   int bc = 1;
   Action act = () => { Console.WriteLine("222" + bc); bc = 2; };
   Action<int, int> act1 = (a, b) => {Console.WriteLine("222" + bc); };
结果为: 2221     2222 
当Lambda语句相同时嵌套类只会有一个对应的函数,Action委托中都只是存了相同的指针
一个很经典的例子：  
	Action[] b = new Action[5];
	for (int i = 0; i < 5; i++)
	{
		b[i] = () => { Console.WriteLine("111" + i); };
	}
结果都为 1114 因为他们共享了相同的对象和指针 所以i都是4,一种高级的用法就是在语句中改变变量的值.
有一个很经典的例子：
	Action[] b = new Action[5];
	for (int i = 0; i < 5; i++)
	{
		int index = i;
		b[i] = () => { Console.WriteLine("111" + index);  };
	}
结果为 1110,1111,1112,1113,1114
如果是这样写的话 编译器会为每个lambda表达式都构造一个对象并存入每一个index的值
public delegate void MessageGet();  内部解析：MessageGet其实是一个内嵌类 继承Delegate 
MessageGet messageGet;  声明一个MessageGet类型的变量 
messageGet = () => { Console.WriteLine("111111"); }; lambda用自己内嵌类对象和对象的方法指针
作为参数构造了一个MessageGet对象,调用时其实就是通过方法的指针
messageGet()  == messageGet.Invoke()
事件是对委托的一层封装 
事件是委托类型的成员 委托是类型
事件会为其所在的类中增加remove和add两个方法 对应 -= +=  
事件成员在其class外部不能使用invoke 即调用方法（只能使用+= 或者-= 不能进行其他操作 比如= 赋值操作）
事件能够增加安全性 暴露的接口少

简单的看了Dictionary的实现：Dictionary有两个核心的变量 一个叫 buckets 用来存储真正的key所对应的下标，
一个叫entries,是一个结构体数组 存储了哈希值 key value next(下一个index) ,当往字典中插入时，key会进行
哈希运算 int num = this.comparer.GetHashCode(key) & 0x7fff_ffff; 
int index = num % this.buckets.Length; 
再用index去buckets用寻找真正的下标代入到entries中如果key正好和所需的key相同就返回，否则继续从next中遍历

NGUI Panel >>>>>> 简单看了一下NGUI的渲染,最主要的类是一个UIDrawCall,继承MonoBehaviour,其实是一个游戏物体,只不过
被隐藏了,当初觉得所有继承widget的组件其实很奇怪因为他们没有材质没有Render那怎么能渲染出东西呢,其实渲染的工作
都在DrawCall上,Panel会对所有他底下的Widget进行depth升序,然后进行循环遍历如果连续的两个widget的shader material texture
相同,那么会合并mesh,这个工作交给UIDrawCall完成.

Render SetPropertyBlock  在项目中多次遇到bug都是因为这个方法会重新设置shader的属性 想要增加改动必须先获取到PropertyBlock
在该对象上进行增加删除

UI框架:音效系统 封装点击按钮 增加声音字段
项目中的动画播放运行在每帧的时间上,若那一帧的时间过长很容易会出现bug 如动画不播放
只要调用过render.material,那材质球就会替换成material instance 在编辑器中的话就会丢失

一帧中的执行顺序。
C/S逻辑层共用一套C#代码,客户端通过 csharp.lua 转换成lua运行,好处是可以用C#来开发且可以热更新整个战斗模块。战斗使用ECS处理英雄的各种操作。ModelComponent负责英雄在界面上的显示。ProcessSystem是英雄的状态机,控制英雄的行为。每个状态都由一个独立的lua文件来控制。逻辑层的状态改变会通过协议的形式分发到表现层，表现层通过不同的协议进行处理。动画攻击，蓄力点通过工具导出每个动画的打点时间来计算。战斗中的每一个组件都会附加一个TimeClock接口用于二倍数制作。