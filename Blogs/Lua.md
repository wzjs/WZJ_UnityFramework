# Lua笔记

## GC
1. 垃圾回收时会暂停所有线程 和Lua不同所有他们用了不同的GC算法  两色标记 和 三色标记  
lua在5.0之前使用简单的扫描标记清除没有引用的对象 这样做会把整个虚拟机的table遍历一遍会导致 stop the world,非常影响性能和卡顿,5.1用了步进器收集器
大致就是gc会按照步骤进行回收,不会一次性进行一次完整的垃圾回收,从而导致卡顿,5.1新增了两个概念，间歇率和步进倍率,
间歇率来控制两次完整Gc的间隔,它是根据上一次内存使用量为基准 判断下一次内存使用量达到某一个倍率时会触发，比如200 就是达到上一次的2倍
步进器倍率是指每一步执行速度的间隔,是收集器运作速度相对于内存分配速度的倍率

## 语法
1. ... 只能放在参数末尾，否则是提取第一个参数
lua ...表示可变参数 function Test(...) Test(1,2,3) 那么这个...就代表 1,2,3  
 local a,b,c = ...   会分别赋值给a,b,c   local a = ... 则 a = 1

 2. Lua Table 简单总结一下Table的用法对应C源码中是如何实现
1. Table的查找 t[1] t[1.2] t["xx"] t[func] ..
ltable luaH_get 首先会判断key的类型，若key是整型并且在数组的范围之内会直接返回对应数组元素 key-1 就代表lua下标是从1开始
然后其余会根据类型计算hash然后找到对应Node节点，然后比较Node节点中的Key值是否与目标Key值相等，
若相等就直接返回Value，若不相等则在Node的链表上寻找若还是没有该值则返回nil

2. Table的赋值
首先会查找是否有对应的key，若有直接赋值即可，若没有则查看hash表是否有多余的空间，有就存放在hash表中，若没有则会resize数组和hash表（resize只会发生在判断hash的时候）
比如 a={} a[1] = 1   首先lua会去寻找数组中是否存在该key（判断key是否在数组范围内）是的话直接返回该值 但有可能该值为nil。这里的话因为数组大小为0，所以在hash中寻找 显然没找到这时
resize数组和hash表，遍历这两个数组筛选int类型的key，根据下述规则分配元素，先是(0.5,1] a[1] 符合区间 且利用率大于百分之五十，所以扩张数组到1再因为 int元素为1 > 1 / 2 继续循环 (1,2] 元素为0
数组大小还是为1，  1 == 2 / 2 跳出循环， 最终数组大小为1 
数组中的key不一定是按照从1按顺序排序，数组大小是根据 所有值总数 根据区间超过利用率百分之五十来判断
3. Table的resize规则: 
	array：
	table会计算array中所有元素的数量和node中number类型的元素的数量的总和
	在计算每个区间内（2^(i - 1) + 1 , 2^i）的元素数量，一般情况下 size由array的元素决定
4. ipair  --ipairs 返回了三个值给 for 循环来进行迭代: 迭代函数, 迭代对象 (函数的第一个参数), 以及迭代初始值 0。迭代函数 ipairsaux
ipair只是简单的每次增加1 然后返回相应的值 若遇到nil则停止迭代

5. pairs 会先去寻找元方法_pairs，若找到了则直接带上迭代只执行元方法，否则会先去数组中寻找迭代值是否在范围内，若是就返回并且每次
+1来迭代，若为空则调用C方法来进行迭代,与ipair相同 返回三个参数 迭代函数，迭代对象（函数的第一个参数），以及迭代值初始值为nil
6. # ,luaH_getn :  
1.如果数组部分的size下标(即arr[size-1])为nil,则对这个区间进行二分查找。 
2.如果数组部分的size下标(即arr[size-1])不会空(即刚好被占满),并且哈希部分为空,则直接返回size
3.如果数组部分的size下标(即arr[size-1])不会空(即刚好被占满),并且哈希部分不为空,则以两倍的速率来查找hash表,比如size为8,那么会去查9是否
不会空,如果不会空,则去查找18, 如果18为空,则在9-18 之间做二分查找。
print(#{nil,nil,0}) => 3       这种初始化赋值的方式 虚拟机会一开始就进行长度的计数
local t = {1,2,3}; t[2] = nil; print(#t) => 3    t[2] = nil   只会单纯将 t[2] 置为空
local t = {1,2,3}; t[2] = nil; t["x"] = nil; print(#t) => 1 t["x"] 引发rehash  会移除所有的nil数据 array part： 1 hash part 3
local t = {1,2,3,4,5,6,7,8}; t[16] = 0; print(#t) => 16 
local t = {1,2,3,4,5,6,7,8}; t[15] = 0; print(#t) => 8
解决hash冲突的方式
2.1 开放定址法
2.1.1 线行探查法
2.1.2 平方探查法
2.1.3 双散列函数探查法
2.2 链地址法（拉链法）
2.3 再哈希法
2.4 建立公共溢出区

问题 输出 index 和 i 的区别：
a = {}
local index = 0
for i=1,3 do
	local func = function() 
		print(index)
	end
	table.insert(a,func)
	index = index + 1
end

a[1]()
a[2]()
a[3]()

7. 不同版本的protobuf可以互相序列化和反序列化,即跨平台 
protobuf编译:把proto编译成不同语言的脚本,然后再用脚本中的接口来序列化和反序列化
#define luaL_newlib(L ,reg) luaL_register(L,"protobuf.c",reg)  tolua中C#在lua虚拟机中已经注册了protobuf.c，因此lua中可以直接require "protobuf.c"